<!doctype html>
<html lang="bg">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Симулация на кола — единична страница</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; font-family: sans-serif; }
    html,body { height: 100%; background: #222; color: #ddd; }
    canvas#game { display:block; background: linear-gradient(#4aa, #158); width:100vw; height:100vh; }
    #help {
      position: absolute; left: 12px; top: 12px;
      background: rgba(0,0,0,0.5); padding:8px 10px; border-radius:6px; color:#fff;
      font-size:14px;
    }
    .hud {
      position: absolute; right: 12px; top: 12px;
      background: rgba(0,0,0,0.5); padding:8px 10px; border-radius:6px; color:#fff;
      font-size:14px; text-align:right;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="help">
    <strong>Контроли:</strong> Стрелки / WASD = движение, Space = ръчна спирачка, R = рестарт
  </div>

  <script>
  // Проста 2D симулация на кола (top-down) — всички части в един файл
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = canvas.width = innerWidth;
  let H = canvas.height = innerHeight;

  window.addEventListener('resize', () => { W = canvas.width = innerWidth; H = canvas.height = innerHeight; });

  /* --- INPUT --- */
  const keys = {};
  window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key === ' ') e.preventDefault(); });
  window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

  /* --- CAR CLASS --- */
  class Car {
    constructor(x,y){
      this.x = x; this.y = y;
      this.angle = 0; // radians, 0 = right
      this.speed = 0; // m/s (abstract units)
      this.steering = 0; // -1..1
      this.throttle = 0; // 0..1
      this.brake = 0; // 0..1
      this.fuel = 100; // %
      // physical params (tweak for feel)
      this.mass = 1200; // kg (abstract)
      this.maxEngineForce = 4000; // N
      this.maxBrakeForce = 8000; // N
      this.dragCoef = 0.4257; // air drag proxy
      this.rollingResistance = 12; // proxy
      this.wheelBase = 2.6; // m
      this.maxSteerAngle = Math.PI/4 * 0.6; // radians
      this.length = 4; this.width = 1.8;
      this.radius = Math.hypot(this.length,this.width)/2; // for simple collisions
      // transmission
      this.gears = [ -3.6, 0, 3.6, 2.1, 1.4, 1.0, 0.83 ]; // reverse, neutral, 1..5
      this.currentGear = 2; // start in gear 1 (index 2)
      this.rpm = 800;
      this.idleRpm = 800; this.maxRpm = 7000;
      this.wheelRadius = 0.34; // m
      this.gearChangeTimer = 0;
      this.engineSoundLevel = 0;
    }

    update(dt, controls){
      // controls: throttle(0..1), brake(0..1), steer(-1..1), handbrake(bool)
      if(this.fuel <= 0) controls.throttle = 0; // no fuel -> no engine

      // steering
      const steerTarget = controls.steer;
      const steerSpeed = 6; // how fast steering interpolates
      this.steering += (steerTarget - this.steering) * Math.min(1, steerSpeed*dt);
      const steerAngle = this.steering * this.maxSteerAngle;

      // throttle/brake
      this.throttle = controls.throttle;
      this.brake = controls.brake;

      // compute longitudinal forces
      const engineForce = this.throttle * this.maxEngineForce * this.gears[this.currentGear];
      let brakeForce = -this.brake * this.maxBrakeForce;
      if(controls.handbrake) brakeForce *= 3;

      // drag and rolling resistance
      const drag = -this.dragCoef * this.speed * Math.abs(this.speed);
      const rolling = -this.rollingResistance * this.speed;

      // net force
      const net = engineForce + brakeForce + drag + rolling;
      const accel = net / this.mass;
      this.speed += accel * dt;

      // clamp speed and allow reverse
      const vMax = 60; // m/s (~216 km/h)
      if(this.speed > vMax) this.speed = vMax;
      if(this.speed < -12) this.speed = -12; // reverse limit

      // simple automatic gearbox (shift up/down based on RPM)
      const wheelOmega = Math.max(1e-3, Math.abs(this.speed) / this.wheelRadius);
      const gearRatio = Math.abs(this.gears[this.currentGear]) || 0.0001;
      let estimatedRpm = wheelOmega * gearRatio * 60 / (2*Math.PI);
      if(this.gears[this.currentGear] === 0) estimatedRpm = this.idleRpm * (1 + this.throttle*0.5);
      this.rpm = Math.min(this.maxRpm, Math.max(this.idleRpm, estimatedRpm + this.throttle*1000));

      // gear logic (simple)
      this.gearChangeTimer -= dt;
      if(this.gearChangeTimer <= 0){
        if(this.gears[this.currentGear] !== 0 && this.rpm > 5200 && this.currentGear < this.gears.length-1){
          this.currentGear++;
          this.gearChangeTimer = 0.4;
        } else if(this.gears[this.currentGear] !== 0 && this.rpm < 2000 && this.currentGear > 2){
          this.currentGear--;
          this.gearChangeTimer = 0.2;
        }
        if(this.currentGear === 1 && this.throttle > 0.05) { this.currentGear = 2; }
      }

      // steering changes heading proportional to speed (bicycle model approx.)
      const turningRadius = this.wheelBase / Math.tan(Math.max(1e-4, steerAngle));
      const angularVel = this.speed / turningRadius; // rad/s
      this.angle += angularVel * dt;

      // update position
      this.x += Math.cos(this.angle) * this.speed * dt;
      this.y += Math.sin(this.angle) * this.speed * dt;

      // fuel consumption (simple): consume when throttle > 0 or rpm high
      const fuelUse = (0.00005 * this.rpm/1000 + 0.0002 * this.throttle) * Math.abs(this.speed) * dt;
      this.fuel = Math.max(0, this.fuel - fuelUse);

      // small natural slowdown at low speeds
      if(Math.abs(this.speed) < 0.05) this.speed = 0;
    }

    draw(ctx){
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle);
      // body
      ctx.fillStyle = '#e33';
      ctx.fillRect(-this.length*10/2, -this.width*10/2, this.length*10, this.width*10);
      // windows
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.fillRect(-this.length*10/4, -this.width*10/2+4, this.length*10/2, this.width*10/2-8);
      // wheels
      ctx.fillStyle = '#222';
      const wheelW = 3, wheelH = 8;
      // front-left
      ctx.fillRect(this.length*10/4 - wheelH/2, -this.width*10/2 - wheelW/2, wheelH, wheelW);
      // front-right
      ctx.fillRect(this.length*10/4 - wheelH/2, this.width*10/2 - wheelW/2, wheelH, wheelW);
      // back wheels
      ctx.fillRect(-this.length*10/4 - wheelH/2, -this.width*10/2 - wheelW/2, wheelH, wheelW);
      ctx.fillRect(-this.length*10/4 - wheelH/2, this.width*10/2 - wheelW/2, wheelH, wheelW);
      ctx.restore();
    }
  }

  /* --- WORLD --- */
  const car = new Car(W/2, H/2);
  const obstacles = [];

  // create some obstacles (rectangles)
  function makeObstacles(){
    obstacles.length = 0;
    obstacles.push({x:200, y:200, w:300, h:20});
    obstacles.push({x:600, y:120, w:20, h:220});
    obstacles.push({x:900, y:350, w:300, h:20});
    obstacles.push({x:1200, y:180, w:20, h:300});
    obstacles.push({x:400, y:700, w:400, h:20});
  }
  makeObstacles();

  /* --- COLLISIONS --- */
  function circleRectCollision(cx,cy,r, rect){
    const rx = rect.x, ry = rect.y, rw = rect.w, rh = rect.h;
    const closestX = clamp(cx, rx, rx+rw);
    const closestY = clamp(cy, ry, ry+rh);
    const dx = cx - closestX, dy = cy - closestY;
    return dx*dx + dy*dy <= r*r;
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function resolveCollisions(){
    const margin = 10;
    if(car.x < margin) { car.x = margin; car.speed *= -0.2; }
    if(car.x > W - margin) { car.x = W - margin; car.speed *= -0.2; }
    if(car.y < margin) { car.y = margin; car.speed *= -0.2; }
    if(car.y > H - margin) { car.y = H - margin; car.speed *= -0.2; }

    for(const o of obstacles){
      if(circleRectCollision(car.x, car.y, car.radius*6, o)){
        const nx = -Math.cos(car.angle);
        const ny = -Math.sin(car.angle);
        car.x += nx * 10;
        car.y += ny * 10;
        car.speed *= -0.25;
      }
    }
  }

  /* --- RENDERING & HUD --- */
  function drawGrid(){
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.lineWidth = 1;
    const gap = 50;
    for(let x=0;x<W;x+=gap){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<H;y+=gap){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.restore();
  }

  function drawObstacles(){
    ctx.save();
    ctx.fillStyle = '#333';
    for(const o of obstacles){
      ctx.fillRect(o.x, o.y, o.w, o.h);
    }
    ctx.restore();
  }

  function drawHUD(){
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(10, H-90, 260, 80);
    ctx.fillStyle = '#fff';
    ctx.font = '14px monospace';
    const kmh = Math.round(Math.abs(car.speed*3.6));
    const gearLabel = (car.currentGear === 1) ? 'N' : (car.currentGear === 0 ? 'R' : String(car.currentGear-1));
    ctx.fillText(`Скорост: ${kmh} km/h`, 20, H-60);
    ctx.fillText(`Предавка: ${gearLabel}`, 20, H-40);
    ctx.fillText(`RPM: ${Math.round(car.rpm)}`, 140, H-60);
    ctx.fillText(`Гориво: ${Math.round(car.fuel)}%`, 140, H-40);
    // fuel bar
    ctx.strokeStyle = '#555'; ctx.strokeRect(20, H-30, 200, 12);
    ctx.fillStyle = car.fuel > 20 ? '#3c3' : '#e33';
    ctx.fillRect(20, H-30, 2*car.fuel, 12);
    ctx.restore();
  }

  /* --- MAIN LOOP --- */
  let last = performance.now();
  function loop(now){
    const dt = Math.min(0.05, (now - last)/1000);
    last = now;

    // build controls
    const controls = {
      throttle: (keys['arrowup'] || keys['w']) ? 1 : 0,
      brake: (keys['arrowdown'] || keys['s']) ? 1 : 0,
      steer: ((keys['arrowleft'] || keys['a']) ? -1 : 0) + ((keys['arrowright'] || keys['d']) ? 1 : 0),
      handbrake: !!keys[' '],
    };

    // reverse behavior: if pressing down and speed ~ 0 go into reverse gear
    if(controls.brake && Math.abs(car.speed) < 0.1 && car.fuel>0){
      car.currentGear = 0; // reverse index
    } else if(controls.throttle && car.currentGear === 0 && car.speed > 0.5){
      car.currentGear = 2; // switch to 1st
    } else if(!controls.throttle && car.currentGear === 0 && Math.abs(car.speed) < 0.1){
      car.currentGear = 2;
    }

    car.update(dt, controls);
    resolveCollisions();

    // drawing
    ctx.clearRect(0,0,W,H);
    drawGrid();
    drawObstacles();
    car.draw(ctx);
    drawHUD();

    // restart
    if(keys['r']) { reset(); keys['r']=false; }

    requestAnimationFrame(loop);
  }

  /* --- UTIL --- */
  function reset(){
    car.x = W/2; car.y = H/2; car.angle = 0; car.speed = 0; car.fuel = 100; car.currentGear = 2;
  }
  reset();
  requestAnimationFrame(loop);
  </script>
</body>
</html>
